Giffy
=====

Web-based driver for the following Slack commands:

* **/giffy _[description]_**: Searches for a GIF matching _[description]_ on
  Google Image Search. Dispatched to {GiffyController#search}.
* **/latex _[code]_**: Renders _[code]_ as a LaTeX image.
* **/glare _[message]_**: Prepends glare-eyes to a message.
* **/gotti**: Displays a random
  [@Shit_Gotti_Says](https://twitter.com/Shit_Gotti_Says) quote. Dispatched to
  {TweetsController#gotti}.
* **/ohsq**: Displays a random [@ohsq](https://twitter.com/ohsq) quote.
  Dispatched to {TweetsController#ohsq}.

Getting Started
---------------

You will need to sign up for an API integration account with Slack, and a
webhook token. Once you have done so, modify the
`config/environments/common/slack.yml` accordingly. You will also need to create
slash-command integrations for each of the slash commands you wish to use. When
you do so, you can add their tokens to the `slack.yml` file.

To use `/latex` you will need LaTeX installed (with `pdflatex`), ImageMagick,
and an AWS S3 account. For development you will need credentials in a file at
`~/.aws/credentials` that looks like this:

````
[default]
aws_access_key_id = YOUR_AWS_ACCESS_KEY_ID
aws_secret_access_key = YOUR_AWS_SECRET_ACCESS_KEY
````

For production you will need to set the `AWS_ACCESS_KEY_ID`,
`AWS_SECRET_ACCESS_KEY`, and `AWS_REGION` environment variables. You will need
a bucket named `giffy-latex` with a `public-read` ACL.

You will also need to modify the `config/secrets.yml` with randomly-generated
key bases. You will need to modify the `config/database.yml` with your
production database credentials.

This application requires Ruby 2.2 and PostgreSQL 8.0+. To get started, first
run `bundle install` to install all required gems, then create PostgreSQL
databases named `giffy_development` and `giffy_test`, both owned by a role
called `giffy`:

```` sh
createuser giffy
createdb -O giffy giffy_development
createdb -O giffy giffy_test
````

To seed the database with cached tweets, run `rake db:seed`.

You should be able to run the application using `rails server`, but since this
is a Slack bot, there is no Web front-end. Instead, try running specs with
`rspec spec`.

Documentation
-------------

HTML documentation can be generated by running `rake yard`. Documentation is
stored in the `doc/app` directory.


Slack Commands
--------------

### /giffy

Uses the {Google} helper class to perform a Google image search.

### /gotti and /ohsq

Uses the {Tweet} model to load a random quote from the respective Twitter
account.

Tweets are loaded using the {TwitterIntegration} helper by a scheduled cron job
and cached locally as Tweet records. Twitter API integration is done via the
`@riscfuture` user, which `@ohsq` has granted permissions to (for now).

### /latex

Uses The `pdflatex` binary to render a LaTeX math snippet to a PDF file, and
then ImageMagick to convert it to an image, and then AWS S3 to upload the image.

### /glare

Prepends glare-eyes to a message.

### /spagott

Displays the Spagott image.

API Integration
---------------

### Slack

Slack integration is done via the {Slack} helper. Since slash-commands do not
echo into the channel, Slack fakes this process by having the bot temporarily
assume the user's name and icon. User data for this purpose is cached by the
{User} model. It is lazy-loaded and cached with a one-day expiration.

### API Credentials

API credentials are managed using
[Configoro](https://github.com/RISCfuture/Configoro). Most all credentials are
stored in the `config/environments/common` directory.

Adding Your Own Commands
------------------------

To add your own command, first
[create a new slash-command](https://square.slack.com/services/new/slash-commands/)
on Slack. Choose a URL for it of the format
`https://square-giffy.herokuapp.com/COMMAND_NAME`, replacing `COMMAND_NAME` as
appropriate.
 
Slack will automatically generate a command token for you. Paste this token into
the `config/environments/common/slack.yml` file, associating it with your
command name (without the leading slash).
 
Add an entry to `config/routes.rb` with your `COMMAND_NAME` path, dispatching it
to a new or existing controller/action combo as you see fit.

Add the controller and action. In the controller, you have access to the
{ApplicationController#command #command} method, from which you can data such as
who typed the command, what channel they typed it in, etc.

If you create a new controller, consider adding
`before_action :validate_command` to verify that the originator was Slack and
not an impostor. Consider also calling
{ApplicationController.report_errors_to_slack report_errors_to_slack} to give
the user succinct messages when exceptions are raised.

Use the `Slack.instance` object to post responses and fake-echo the command, as
necessary:

```` ruby
Slack.instance.echo command
Slack.instance.webhook_message command.channel_id, "Hello, world!"
````

Testing
-------

Testing slash-commands is done using RSpec. See the `spec/controllers`
directory for examples of how to test slash-commands using specs. Run specs with
`rspec spec`.

Deployment
----------

This is a Heroku application. It will automatically deploy when commits are
pushed to the remote.
